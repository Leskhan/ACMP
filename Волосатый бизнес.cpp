/*
ACMP
Волосатый бизнес

Одного неформала выгнали с работы, и теперь ему надо как-то зарабатывать себе на жизнь. Поразмыслив, он решил, что сможет иметь очень неплохие деньги на продаже собственных волос. Известно, что пункты приема покупают волосы произвольной длины стоимостью С у.е. за каждый сантиметр. Так как волосяной рынок является очень динамичным, то цена одного сантиметра волос меняется каждый день как и курс валют. Неформал является очень хорошим бизнес-аналитиком. Он смог вычислить, какой будет цена одного сантиметра волос в каждый из ближайших N дней (для удобства пронумеруем дни в хронологическом порядке от 0 до N-1). Теперь он хочет определить, в какие из этих дней ему следует продавать волосы, чтобы по истечению всех N дней заработать максимальное количество денег. Заметим, что волосы у неформала растут только ночью и вырастают на 1 сантиметр за ночь. Следует также учесть, что до 0-го дня неформал с горя подстригся наголо и к 0-му дню длина его волос составляла 1 сантиметр.

Входные данные
В первой строке входного файла INPUT.TXT записано целое число N (0 < N ≤ 100). Во второй строке через пробел заданы N натуральных чисел, не превосходящих 100, соответствующие стоимости C[i] 1 сантиметра волос за каждый i-й день.

Выходные данные
В единственную строку выходного файла OUTPUT.TXT нужно вывести максимальную денежную сумму, которую может заработать неформал за N дней.

Примеры
№	INPUT.TXT	OUTPUT.TXT
1	5
73 31 96 24 46	380
2	10
1 2 3 4 5 6 7 8 9 10	100
3	10
10 9 8 7 6 5 4 3 2 1	55
*/



#include <fstream>
#include <vector>
#include <map>

using namespace std;

int main() {
  ifstream ifst("input.txt");
  ofstream ofst("output.txt");

  size_t n;

  ifst >> n;
  vector<size_t> costs(n);
  map<size_t, size_t, greater<size_t>> sorted_costs;

  for (size_t i = 0; i < n; ++i) {
    ifst >> costs[i];
    ++sorted_costs[costs[i]];
  }

  size_t length = 1;
  size_t cash = 0;
  for (size_t i = 0; i < n; ++i) {
    if (costs[i] == sorted_costs.begin()->first) {
      cash += costs[i] * length;
      length = 0;
    }

    --sorted_costs[costs[i]];
    if (sorted_costs[costs[i]] == 0)
      sorted_costs.erase(costs[i]);

    ++length;
  }
  ofst << cash << endl;
}
